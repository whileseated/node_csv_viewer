<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="styles.css">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<title>CSV/TSV Viewer</title>
</head>
<body>
    <div class="options-container" id="optionsContainer" style="display: none;">
        <span id="rowCount" class="row-count-badge"></span>
        <span id="autoSaveIndicator" class="auto-save-indicator" style="display: none;"></span>
        <a href="#" id="showAllLink" onclick="showAllRows()" style="display: none;">Show All</a>
        <input type="text" id="filterInput" class="filter-input" placeholder="Filter rows..." oninput="filterRows()" />
        <a href="#" id="toggleRankColumnLink" onclick="toggleRankColumn()">Rank</a>
        <a href="#" id="toggleCheckmarkColumnLink" onclick="toggleCheckmarkColumn()">Checkmark</a>
        <a href="#" id="showCheckedRowsLink" onclick="toggleCheckedRows()" style="display: none;">Show Checks</a>
        <a href="#" id="toggleDragHandleLink" onclick="toggleDragHandle()">Drag Handle</a>
        <a href="#" id="exportCSVLink" onclick="exportCSV()" style="display: none;">Export CSV</a>
    </div>

    <div class="bulk-actions-container" id="bulkActionsContainer" style="display: none;">
        <a href="#" id="checkAllLink" onclick="checkAll()">Check All</a>
        <a href="#" id="checkNoneLink" onclick="checkNone()">Check None</a>
    </div>

    <div class="container mt-3">
        <!-- Tab Navigation -->
        <div class="tab-container">
            <button class="add-header-button" id="addHeaderBtn" onclick="showAddHeaderDialog()" style="display: none;" title="Change headers">+</button>
            <span class="current-filename" id="currentFilename"></span>
            <button class="tab-button active" id="uploadTab" onclick="switchTab('upload')">Upload New</button>
            <button class="tab-button" id="savedTab" onclick="switchTab('saved')">Saved Files</button>
        </div>

        <!-- Upload Section -->
        <div id="uploadSection" class="upload-section">
            <div id="dropZone" class="drop-zone">
                <div class="drop-zone-icon">â‡ª</div>
                <div class="drop-zone-text">Drop CSV or TSV file here</div>
                <div class="drop-zone-or">or</div>
                <label for="csvFile" class="file-button">Choose File</label>
                <input type="file" id="csvFile" class="file-input" accept=".csv,.tsv,.txt" />
                <div class="drop-zone-hint">Supports .csv, .tsv, and .txt files</div>
            </div>
        </div>

        <!-- Saved Files Section -->
        <div id="savedFilesSection" class="saved-files-section" style="display: none;">
            <div class="saved-files-container">
                <div id="savedFilesContent">
                    <div class="loading-indicator" id="savedFilesLoading" style="display: none;">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Loading saved files...</div>
                    </div>
                    <div id="savedFilesList"></div>
                </div>
            </div>
        </div>

        <div id="loadingIndicator" class="loading-indicator" style="display: none;">
            <div class="loading-spinner"></div>
            <div class="loading-text">Processing file...</div>
            <div class="loading-details" id="loadingDetails">Parsing rows...</div>
        </div>

        <div class="table-container" id="tableContainer" style="display: none;">
            <table class="table table-striped" id="csvTable">
                <thead class="table-header"></thead>
                <tbody class="table-body"></tbody>
            </table>
        </div>
    </div>

    <script>
        let currentData = [];
        let currentHeaders = null;
        let rawFileData = []; // Store raw file data before headers are applied
        let hasCustomHeaders = false; // Track if user has set custom headers
        let showRankColumn = false;
        let showCheckboxColumn = false;
        let showDragHandle = false;
        let checkedRows = new Set();
        let showCheckedRows = false;
        let currentSort = { column: null, ascending: true }; // Define the current sorting state
        let allData = []; // Store the complete dataset for toggling back
        let unfilteredData = []; // Store data before filter is applied
        let hasSignificantAdjustments = false; // Track if export should be available
        let lastCheckedIndex = null; // Track last checked checkbox for shift-click
        let columnWidths = {}; // Store custom column widths
        let isResizing = false;
        let currentResizeColumn = null;
        let startX = 0;
        let startWidth = 0;
        let currentFilter = ''; // Track current filter text
        let currentSavedFilename = null; // Track currently loaded saved file for auto-save
        let autoSaveTimeout = null; // Debounce timer for auto-save

        // File input event listener
        document.getElementById('csvFile').addEventListener('change', uploadFile);

        // Drag and drop event listeners
        const dropZone = document.getElementById('dropZone');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const validExtensions = ['.csv', '.tsv', '.txt'];
                const isValid = validExtensions.some(ext => file.name.toLowerCase().endsWith(ext));

                if (isValid) {
                    processFile(file, file.name);
                } else {
                    alert('Please drop a CSV, TSV, or TXT file');
                }
            }
        });

        async function uploadFile() {
            const csvFile = document.getElementById('csvFile').files[0];
            if (csvFile) {
                // Clear saved filename when uploading new file
                currentSavedFilename = null;
                processFile(csvFile, csvFile.name);
            }
        }

        // Auto-save functionality
        function triggerAutoSave() {
            if (!currentSavedFilename) {
                return; // Only auto-save if file was loaded from saved files
            }

            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }

            // Debounce: wait 500ms after last change before saving
            autoSaveTimeout = setTimeout(async () => {
                await performAutoSave();
            }, 500);
        }

        async function performAutoSave() {
            if (!currentSavedFilename || !currentData || currentData.length === 0) {
                return;
            }

            const indicator = document.getElementById('autoSaveIndicator');
            indicator.textContent = 'Saving...';
            indicator.style.display = 'inline-block';

            try {
                // Generate CSV content (same as export)
                const csvContent = generateCSVContent();

                // Send update to server
                const response = await fetch(`/api/update/${encodeURIComponent(currentSavedFilename)}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ content: csvContent })
                });

                const data = await response.json();

                if (data.success) {
                    indicator.textContent = 'Saved';
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 2000);
                } else {
                    indicator.textContent = 'Save failed';
                    console.error('Auto-save failed:', data.error);
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 3000);
                }
            } catch (error) {
                console.error('Auto-save error:', error);
                indicator.textContent = 'Save failed';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 3000);
            }
        }

        function processFile(file, filename) {
            // Update filename display
            const filenameElement = document.getElementById('currentFilename');
            if (filename) {
                filenameElement.textContent = filename;
            }

            // Hide add header button while processing
            document.getElementById('addHeaderBtn').style.display = 'none';

            // Show loading indicator
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('loadingIndicator').style.display = 'block';

            const fileSize = (file.size / 1024 / 1024).toFixed(1); // Size in MB
            document.getElementById('loadingDetails').textContent = `Reading ${fileSize}MB file...`;

            let rowCount = 0;
            let lastUpdate = Date.now();
            let allChunks = []; // Accumulate chunks here

            Papa.parse(file, {
                header: false,
                dynamicTyping: true,
                skipEmptyLines: true,
                delimiter: "",
                chunk: function(results, parser) {
                    // Accumulate data from chunks
                    if (results && results.data) {
                        allChunks.push(...results.data);
                        rowCount += results.data.length;
                    }

                    // Update UI every 200ms to avoid too many updates
                    const now = Date.now();
                    if (now - lastUpdate > 200) {
                        const rowsFormatted = rowCount >= 1000
                            ? `${(rowCount / 1000).toFixed(1)}K`
                            : rowCount;
                        document.getElementById('loadingDetails').textContent =
                            `Parsed ${rowsFormatted} rows from ${fileSize}MB file...`;
                        lastUpdate = now;
                    }
                },
                complete: function (results) {
                    // Log results for debugging
                    console.log('Parse complete. Chunks collected:', allChunks.length);

                    // Use accumulated chunks instead of results.data
                    const data = allChunks;

                    // Check if we have any data
                    if (!data || data.length === 0) {
                        console.error('No data was parsed from the file');
                        document.getElementById('loadingIndicator').style.display = 'none';
                        document.getElementById('uploadSection').style.display = 'block';
                        alert("The file appears to be empty or could not be parsed.");
                        return;
                    }

                    // Log any parsing errors but continue
                    if (results && results.errors && results.errors.length > 0) {
                        console.warn(`Parsing completed with ${results.errors.length} errors:`, results.errors);
                    }

                    const totalRows = data.length;
                    const rowsFormatted = totalRows >= 1000
                        ? `${(totalRows / 1000).toFixed(1)}K`
                        : totalRows;

                    document.getElementById('loadingDetails').textContent =
                        `Processing ${rowsFormatted} rows...`;

                    // Ensure there's data in the file
                    if (data.length === 0) {
                        document.getElementById('loadingIndicator').style.display = 'none';
                        document.getElementById('uploadSection').style.display = 'block';
                        alert("The file is empty.");
                        return;
                    }

                    // Store raw data for later header manipulation
                    rawFileData = data;
                    hasCustomHeaders = false;

                    // Always use first row as headers by default
                    const firstRow = data[0];
                    currentHeaders = firstRow;
                    currentData = data.slice(1);

                    const dataRowsFormatted = currentData.length >= 1000
                        ? `${(currentData.length / 1000).toFixed(1)}K`
                        : currentData.length;

                    document.getElementById('loadingDetails').textContent =
                        `Mapping ${dataRowsFormatted} rows to columns...`;

                    // Use setTimeout to allow UI update before heavy processing
                    setTimeout(() => {
                        // Check if there's a "Checked" or "Rank" column in the headers
                        const checkedColumnIndex = currentHeaders.indexOf('Checked');
                        const rankColumnIndex = currentHeaders.indexOf('Rank');
                        const hasCheckedColumn = checkedColumnIndex !== -1;
                        const hasRankColumn = rankColumnIndex !== -1;

                        // Map the remaining rows to the headers, and add a unique ID
                        currentData = currentData.map((row, index) => {
                            const mappedRow = { ID: index + 1 };
                            currentHeaders.forEach((header, i) => {
                                mappedRow[header] = row[i] !== undefined ? row[i] : '';
                            });
                            return mappedRow;
                        });

                        // If there's a "Checked" column, restore checkbox states
                        if (hasCheckedColumn) {
                            checkedRows.clear();
                            currentData.forEach(row => {
                                const checkedValue = String(row['Checked']).toUpperCase();
                                if (checkedValue === 'TRUE' || checkedValue === '1' || checkedValue === 'YES') {
                                    checkedRows.add(row.ID);
                                }
                            });

                            // Remove "Checked" from headers (it's UI state, not data)
                            currentHeaders = currentHeaders.filter(h => h !== 'Checked');

                            // Remove "Checked" column from data
                            currentData = currentData.map(row => {
                                const newRow = { ...row };
                                delete newRow['Checked'];
                                return newRow;
                            });

                            // Enable checkbox column
                            showCheckboxColumn = true;
                        }

                        // If there's a "Rank" column, remove it and enable rank column
                        if (hasRankColumn) {
                            // Remove "Rank" from headers (it's UI state, not data)
                            currentHeaders = currentHeaders.filter(h => h !== 'Rank');

                            // Remove "Rank" column from data
                            currentData = currentData.map(row => {
                                const newRow = { ...row };
                                delete newRow['Rank'];
                                return newRow;
                            });

                            // Enable rank column
                            showRankColumn = true;
                        }

                        allData = [...currentData];

                        document.getElementById('loadingDetails').textContent =
                            `Rendering ${dataRowsFormatted} rows...`;

                        // Use setTimeout to allow UI to update before rendering
                        setTimeout(() => {
                            // Hide loading and show table
                            document.getElementById('loadingIndicator').style.display = 'none';
                            document.getElementById('tableContainer').style.display = 'block';
                            document.getElementById('optionsContainer').style.display = 'flex';

                            // Show add header button if using default headers
                            if (!hasCustomHeaders) {
                                document.getElementById('addHeaderBtn').style.display = 'block';
                            }

                            // Clear filter input and state
                            document.getElementById('filterInput').value = '';
                            currentFilter = '';
                            unfilteredData = [];

                            // Update button states if they were automatically enabled
                            if (showCheckboxColumn) {
                                document.getElementById('toggleCheckmarkColumnLink').classList.add('active');
                            }
                            if (showRankColumn) {
                                document.getElementById('toggleRankColumnLink').classList.add('active');
                            }

                            displayData(currentData);
                            updateUIVisibility(); // Ensure UI state is correct
                        }, 50);
                    }, 50);
                },
                error: function (error) {
                    console.error('Parsing Error:', error);
                    document.getElementById('loadingIndicator').style.display = 'none';
                    document.getElementById('uploadSection').style.display = 'block';

                    let errorMsg = "An error occurred while parsing the file.";
                    if (error.message) {
                        errorMsg += `\n\nError: ${error.message}`;
                    }
                    if (error.row !== undefined) {
                        errorMsg += `\nRow: ${error.row}`;
                    }
                    errorMsg += "\n\nCheck the browser console for more details.";

                    alert(errorMsg);
                }
            });
        }

        function displayData(data) {
            if (!data || data.length === 0 || !currentHeaders) {
                console.error("No data or headers to display");
                return;
            }

            // Update row count display
            const rowCountElement = document.getElementById('rowCount');
            const formattedCount = data.length >= 1000
                ? `${(data.length / 1000).toFixed(1)}K`
                : data.length;
            rowCountElement.textContent = `${formattedCount} rows`;

            const tableHeader = document.querySelector('.table-header');
            const tableBody = document.querySelector('.table-body');

            // Create the header row with sorting functionality
            let headerRow = '<tr>';
            if (showDragHandle) headerRow += '<th style="width: 40px;">â ¿</th>';
            if (showRankColumn) headerRow += '<th>Rank</th>';
            if (showCheckboxColumn) headerRow += '<th>Check</th>';
            currentHeaders.forEach((header, index) => {
                let sortClass = 'sortable';
                if (currentSort.column === header) {
                    sortClass += currentSort.ascending ? ' sorted-asc' : ' sorted-desc';
                }
                const width = columnWidths[header] ? `style="width: ${columnWidths[header]}px;"` : '';
                headerRow += `<th class="${sortClass} resizable-header" ${width} data-column="${header}">
                    <span onclick="sortData('${header}')">${header}</span>
                    <div class="resize-handle" data-column="${header}"></div>
                </th>`;
            });
            headerRow += '</tr>';
            tableHeader.innerHTML = headerRow;

            // Attach resize event listeners
            attachResizeListeners();

            // Create the data rows with drag-and-drop functionality
            // Use array join instead of innerHTML concatenation for better performance
            const rows = data.map((row, rowIndex) => {
                let dataRow = `<tr ondragover="handleDragOver(event)" ondrop="handleDrop(event, ${rowIndex})">`;

                if (showDragHandle) {
                    dataRow += `<td class="drag-handle" draggable="true" ondragstart="handleDragStart(event, ${rowIndex})" style="cursor: grab; text-align: center;">â ¿</td>`;
                }
                if (showRankColumn) dataRow += `<td>${rowIndex + 1}</td>`;
                if (showCheckboxColumn) {
                    const isChecked = checkedRows.has(row.ID) ? 'checked' : '';
                    dataRow += `<td><input type="checkbox" ${isChecked} onclick="handleCheckboxChange(${row.ID}, ${rowIndex}, this, event)"></td>`;
                }
                currentHeaders.forEach(header => {
                    const cellValue = row[header];
                    const formattedValue = makeLinksClickable(cellValue);
                    dataRow += `<td>${formattedValue}</td>`;
                });
                dataRow += '</tr>';
                return dataRow;
            });

            tableBody.innerHTML = rows.join('');

            // Update the checked rows button text to reflect current count
            if (showCheckboxColumn) {
                updateCheckedRowsButtonText();
            }
        }

        function makeLinksClickable(text) {
            if (text === null || text === undefined || text === '') return '';

            const textStr = String(text);
            // Quick check: if no http in the string, skip regex
            if (!textStr.includes('http://') && !textStr.includes('https://')) {
                return textStr;
            }

            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return textStr.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
        }

        function updateUIVisibility() {
            // Show "Show Only Checked Rows" only when checkboxes are enabled
            const showCheckedRowsLink = document.getElementById('showCheckedRowsLink');
            if (showCheckboxColumn) {
                showCheckedRowsLink.style.display = 'inline-block';
            } else {
                showCheckedRowsLink.style.display = 'none';
            }

            // Show bulk actions (Check All, Check None) only when checkboxes are enabled
            const bulkActionsContainer = document.getElementById('bulkActionsContainer');
            if (showCheckboxColumn) {
                bulkActionsContainer.style.display = 'flex';
            } else {
                bulkActionsContainer.style.display = 'none';
            }

            // Show export button only when significant adjustments have been made
            const exportLink = document.getElementById('exportCSVLink');
            if (hasSignificantAdjustments) {
                exportLink.style.display = 'inline-block';
            } else {
                exportLink.style.display = 'none';
            }

            // Show "Show All" button when viewing filtered data
            const showAllLink = document.getElementById('showAllLink');
            if (showCheckedRows || currentFilter !== '') {
                showAllLink.style.display = 'inline-block';
            } else {
                showAllLink.style.display = 'none';
            }

            // Update the checked rows button text with count
            updateCheckedRowsButtonText();
        }

        function updateCheckedRowsButtonText() {
            const showCheckedRowsLink = document.getElementById('showCheckedRowsLink');
            const count = checkedRows.size;

            if (showCheckedRows) {
                showCheckedRowsLink.textContent = `Showing ${count} Check${count === 1 ? '' : 's'}`;
            } else {
                if (count > 0) {
                    showCheckedRowsLink.textContent = `Show ${count} Check${count === 1 ? '' : 's'}`;
                } else {
                    showCheckedRowsLink.textContent = 'Show Checks';
                }
            }
        }

        function markAsAdjusted() {
            hasSignificantAdjustments = true;
            updateUIVisibility();
        }

        function toggleRankColumn() {
            showRankColumn = !showRankColumn;
            document.getElementById('toggleRankColumnLink').classList.toggle('active', showRankColumn);
            if (showRankColumn) {
                markAsAdjusted();
            } else {
                // Still update visibility when toggling off
                updateUIVisibility();
            }
            displayData(currentData);
        }

        function toggleCheckmarkColumn() {
            showCheckboxColumn = !showCheckboxColumn;
            document.getElementById('toggleCheckmarkColumnLink').classList.toggle('active', showCheckboxColumn);
            if (showCheckboxColumn) {
                markAsAdjusted();
            } else {
                // Still update visibility when toggling off
                updateUIVisibility();
            }
            displayData(currentData);
        }

        function toggleDragHandle() {
            showDragHandle = !showDragHandle;
            document.getElementById('toggleDragHandleLink').classList.toggle('active', showDragHandle);
            displayData(currentData);
        }

        function handleCheckboxChange(rowID, rowIndex, checkboxElem, event) {
            // Handle shift-click range selection
            if (event.shiftKey && lastCheckedIndex !== null && lastCheckedIndex !== rowIndex) {
                const start = Math.min(lastCheckedIndex, rowIndex);
                const end = Math.max(lastCheckedIndex, rowIndex);

                // Determine if we're checking or unchecking based on current checkbox state
                const shouldCheck = checkboxElem.checked;

                // Check or uncheck all rows in the range
                for (let i = start; i <= end; i++) {
                    const currentRow = currentData[i];
                    if (currentRow) {
                        if (shouldCheck) {
                            checkedRows.add(currentRow.ID);
                        } else {
                            checkedRows.delete(currentRow.ID);
                        }
                    }
                }

                // Refresh the display to show all checked boxes
                displayData(currentData);
            } else {
                // Normal single checkbox toggle
                if (checkboxElem.checked) {
                    checkedRows.add(rowID);
                } else {
                    checkedRows.delete(rowID);
                }
            }

            lastCheckedIndex = rowIndex;
            updateCheckedRowsButtonText();
            triggerAutoSave();
        }

        function checkAll() {
            currentData.forEach(row => {
                checkedRows.add(row.ID);
            });
            displayData(currentData);
            updateCheckedRowsButtonText();
            triggerAutoSave();
        }

        function checkNone() {
            checkedRows.clear();
            displayData(currentData);
            updateCheckedRowsButtonText();
            triggerAutoSave();
        }

        // Column resizing functionality
        function attachResizeListeners() {
            const resizeHandles = document.querySelectorAll('.resize-handle');

            resizeHandles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    isResizing = true;
                    currentResizeColumn = handle.getAttribute('data-column');
                    startX = e.pageX;

                    const th = handle.closest('th');
                    startWidth = th.offsetWidth;

                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                });
            });
        }

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            const diff = e.pageX - startX;
            const newWidth = Math.max(50, startWidth + diff); // Minimum width of 50px

            columnWidths[currentResizeColumn] = newWidth;

            // Update the column width immediately
            const th = document.querySelector(`th[data-column="${currentResizeColumn}"]`);
            if (th) {
                th.style.width = newWidth + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                currentResizeColumn = null;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        function toggleCheckedRows() {
            showCheckedRows = !showCheckedRows;

            if (showCheckedRows) {
                // Only display rows that are checked
                const filteredData = allData.filter(row => checkedRows.has(row.ID));
                displayData(filteredData);
                markAsAdjusted();
            } else {
                // Show all rows again
                displayData(allData);
            }

            document.getElementById('showCheckedRowsLink').classList.toggle('active', showCheckedRows);
            updateCheckedRowsButtonText();
            updateUIVisibility();
        }

        function showAllRows() {
            // Reset checked rows filter
            if (showCheckedRows) {
                showCheckedRows = false;
                document.getElementById('showCheckedRowsLink').classList.remove('active');
                updateCheckedRowsButtonText();
            }

            // Reset search filter
            if (currentFilter !== '') {
                document.getElementById('filterInput').value = '';
                currentFilter = '';
            }

            // Restore all data
            if (unfilteredData.length > 0) {
                currentData = [...unfilteredData];
                unfilteredData = [];
            } else {
                currentData = [...allData];
            }

            displayData(currentData);
            updateUIVisibility();
        }

        // Filter rows based on search term
        function filterRows() {
            const filterInput = document.getElementById('filterInput');
            const filterText = filterInput.value.toLowerCase().trim();

            // If filter is empty, restore unfiltered data
            if (filterText === '') {
                if (currentFilter !== '') {
                    // Was filtering before, now clearing
                    currentData = unfilteredData.length > 0 ? [...unfilteredData] : [...currentData];
                    currentFilter = '';
                    displayData(currentData);
                    updateUIVisibility();
                }
                return;
            }

            // Store unfiltered data if this is the first filter
            if (currentFilter === '') {
                unfilteredData = [...currentData];
            }

            // Filter data - search across all columns
            const filtered = unfilteredData.filter(row => {
                // Check each column value
                return currentHeaders.some(header => {
                    const value = row[header];
                    if (value === null || value === undefined) return false;
                    return String(value).toLowerCase().includes(filterText);
                });
            });

            currentFilter = filterText;
            currentData = filtered;
            displayData(currentData);

            // Mark as adjusted if filter is active
            if (filterText !== '') {
                markAsAdjusted();
            }

            updateUIVisibility();
        }

        function parseCSV(file) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    complete: (result) => {
                        console.log('Parsed Data:', result.data); // Debugging line
                        resolve(result.data);
                    },
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true,
                    error: (error) => {
                        console.error('Parsing Error:', error); // Error handling
                        reject(error);
                    },
                });
            });
        }

        // Drag-and-drop row reordering functionality
        function handleDragStart(event, index) {
            draggedRowIndex = index;
            event.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(event, index) {
            event.preventDefault();
            if (draggedRowIndex !== null && draggedRowIndex !== index) {
                const draggedRow = currentData.splice(draggedRowIndex, 1)[0];
                currentData.splice(index, 0, draggedRow);
                markAsAdjusted();
                displayData(currentData);
                triggerAutoSave();
            }
        }

        // Sorting functionality
        function sortData(column) {
            // Toggle sorting order if the same column is clicked again
            if (currentSort.column === column) {
                currentSort.ascending = !currentSort.ascending;
            } else {
                currentSort.column = column;
                currentSort.ascending = true;
            }

            // Sort function to be used for both arrays
            const sortFunction = (a, b) => {
                const valA = a[column];
                const valB = b[column];

                if (valA < valB) return currentSort.ascending ? -1 : 1;
                if (valA > valB) return currentSort.ascending ? 1 : -1;
                return 0;
            };

            // Sort both the current data and all data to maintain sort across filters
            currentData.sort(sortFunction);
            allData.sort(sortFunction);

            markAsAdjusted();

            // If showing only checked rows, re-filter after sorting
            if (showCheckedRows) {
                const filteredData = allData.filter(row => checkedRows.has(row.ID));
                displayData(filteredData);
            } else {
                displayData(currentData);
            }

            triggerAutoSave();
        }

        // Export CSV functionality
        function exportCSV() {
            if (!currentData || currentData.length === 0 || !currentHeaders) {
                alert("No data to export");
                return;
            }

            // Show export dialog
            showExportDialog();
        }

        function generateCSVContent() {
            // Build CSV content
            let csvContent = '';

            // Add headers
            let headers = [];
            if (showRankColumn) {
                headers.push('Rank');
            }
            if (showCheckboxColumn) {
                headers.push('Checked');
            }
            headers = headers.concat(currentHeaders);
            csvContent += headers.map(h => `"${h}"`).join(',') + '\n';

            // Add data rows (use currentData which reflects current view/sort/filter)
            const dataToExport = showCheckedRows
                ? currentData
                : currentData;

            dataToExport.forEach((row, index) => {
                let rowData = [];

                // Add rank if enabled
                if (showRankColumn) {
                    rowData.push(index + 1);
                }

                // Add checked state if checkboxes enabled
                if (showCheckboxColumn) {
                    rowData.push(checkedRows.has(row.ID) ? 'TRUE' : 'FALSE');
                }

                // Add all other columns
                currentHeaders.forEach(header => {
                    const value = row[header];
                    // Escape quotes and wrap in quotes if contains comma, quote, or newline
                    const stringValue = value !== null && value !== undefined ? String(value) : '';
                    const escapedValue = stringValue.replace(/"/g, '""');
                    rowData.push(`"${escapedValue}"`);
                });

                csvContent += rowData.join(',') + '\n';
            });

            return csvContent;
        }

        function downloadCSV() {
            const csvContent = generateCSVContent();

            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `csv_export_${timestamp}.csv`;

            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Tab switching functionality
        function switchTab(tab) {
            if (tab === 'upload') {
                document.getElementById('uploadTab').classList.add('active');
                document.getElementById('savedTab').classList.remove('active');
                document.getElementById('uploadSection').style.display = 'block';
                document.getElementById('savedFilesSection').style.display = 'none';
                // Show add header button if using default headers
                if (!hasCustomHeaders && currentData.length > 0) {
                    document.getElementById('addHeaderBtn').style.display = 'block';
                }
                // Show filename if we have data loaded
                // (filename is already set by processFile, so no need to change it here)
            } else if (tab === 'saved') {
                // Check if saved tab is already active - if so, just collapse the list
                const savedTabActive = document.getElementById('savedTab').classList.contains('active');
                const savedFilesVisible = document.getElementById('savedFilesSection').style.display === 'block';

                if (savedTabActive && savedFilesVisible) {
                    // Just collapse the saved files list, keep button active
                    document.getElementById('savedFilesSection').style.display = 'none';
                } else {
                    // Show saved files
                    document.getElementById('uploadTab').classList.remove('active');
                    document.getElementById('savedTab').classList.add('active');
                    document.getElementById('uploadSection').style.display = 'none';
                    document.getElementById('savedFilesSection').style.display = 'block';
                    // Hide add header button when viewing saved files
                    document.getElementById('addHeaderBtn').style.display = 'none';
                    // Load saved files when switching to this tab
                    loadSavedFiles();
                }
            }
        }

        // Saved files management
        async function loadSavedFiles() {
            const loadingIndicator = document.getElementById('savedFilesLoading');
            const filesList = document.getElementById('savedFilesList');

            loadingIndicator.style.display = 'block';
            filesList.innerHTML = '';

            try {
                const response = await fetch('/api/saved-files');
                const data = await response.json();

                loadingIndicator.style.display = 'none';

                if (!data.success) {
                    filesList.innerHTML = '<div class="empty-state">Error loading files</div>';
                    return;
                }

                if (data.files.length === 0) {
                    filesList.innerHTML = '<div class="empty-state">No saved files yet. Upload and save a CSV to get started.</div>';
                    return;
                }

                // Build table
                let tableHTML = `
                    <table class="saved-files-table">
                        <thead>
                            <tr>
                                <th>Filename</th>
                                <th>Size</th>
                                <th>Last Modified</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                data.files.forEach(file => {
                    const size = formatFileSize(file.size);
                    const date = formatDate(file.lastModified);
                    tableHTML += `
                        <tr>
                            <td class="filename-cell">
                                <span class="filename-display" id="filename-${file.filename}">${file.filename}</span>
                                <input type="text" class="filename-input" id="input-${file.filename}"
                                       value="${file.filename}" style="display: none;">
                            </td>
                            <td>${size}</td>
                            <td>${date}</td>
                            <td>
                                <div class="file-actions">
                                    <button class="file-action-btn" onclick="loadSavedFile('${file.filename}')">Load</button>
                                    <button class="file-action-btn" onclick="startRename('${file.filename}')">Rename</button>
                                    <button class="file-action-btn delete" onclick="deleteSavedFile('${file.filename}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table>';
                filesList.innerHTML = tableHTML;
            } catch (error) {
                console.error('Error loading saved files:', error);
                loadingIndicator.style.display = 'none';
                filesList.innerHTML = '<div class="empty-state">Error loading files</div>';
            }
        }

        async function loadSavedFile(filename) {
            try {
                const response = await fetch(`/api/file/${encodeURIComponent(filename)}`);
                if (!response.ok) {
                    throw new Error('Failed to load file');
                }

                const blob = await response.blob();
                const file = new File([blob], filename, { type: 'text/csv' });

                // Reset header state when loading a saved file
                hasCustomHeaders = false;
                rawFileData = [];

                // Track which saved file is loaded for auto-save
                currentSavedFilename = filename;

                // Switch to upload tab and process the file
                switchTab('upload');
                processFile(file, filename);
            } catch (error) {
                console.error('Error loading file:', error);
                alert('Failed to load file: ' + error.message);
            }
        }

        function startRename(filename) {
            const displaySpan = document.getElementById(`filename-${filename}`);
            const inputField = document.getElementById(`input-${filename}`);

            displaySpan.style.display = 'none';
            inputField.style.display = 'inline-block';
            inputField.focus();
            inputField.select();

            // Handle Enter key
            inputField.onkeydown = async (e) => {
                if (e.key === 'Enter') {
                    await finishRename(filename, inputField.value);
                } else if (e.key === 'Escape') {
                    cancelRename(filename);
                }
            };

            // Handle blur (clicking outside)
            inputField.onblur = async () => {
                if (inputField.value !== filename) {
                    await finishRename(filename, inputField.value);
                } else {
                    cancelRename(filename);
                }
            };
        }

        async function finishRename(oldFilename, newFilename) {
            if (newFilename === oldFilename) {
                cancelRename(oldFilename);
                return;
            }

            if (!newFilename || newFilename.trim() === '') {
                alert('Filename cannot be empty');
                cancelRename(oldFilename);
                return;
            }

            try {
                const response = await fetch(`/api/rename/${encodeURIComponent(oldFilename)}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ newFilename: newFilename })
                });

                const data = await response.json();

                if (!data.success) {
                    alert('Failed to rename file: ' + data.error);
                    cancelRename(oldFilename);
                    return;
                }

                // Reload the files list
                loadSavedFiles();
            } catch (error) {
                console.error('Error renaming file:', error);
                alert('Failed to rename file: ' + error.message);
                cancelRename(oldFilename);
            }
        }

        function cancelRename(filename) {
            const displaySpan = document.getElementById(`filename-${filename}`);
            const inputField = document.getElementById(`input-${filename}`);

            displaySpan.style.display = 'inline';
            inputField.style.display = 'none';
        }

        async function deleteSavedFile(filename) {
            if (!confirm(`Are you sure you want to delete "${filename}"? This cannot be undone.`)) {
                return;
            }

            try {
                const response = await fetch(`/api/delete/${encodeURIComponent(filename)}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (!data.success) {
                    alert('Failed to delete file: ' + data.error);
                    return;
                }

                // Reload the files list
                loadSavedFiles();
            } catch (error) {
                console.error('Error deleting file:', error);
                alert('Failed to delete file: ' + error.message);
            }
        }

        // Export dialog functionality
        function showExportDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'export-dialog-overlay';
            overlay.id = 'exportOverlay';

            const dialog = document.createElement('div');
            dialog.className = 'export-dialog';
            dialog.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: bold;">Export CSV</div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; cursor: pointer;">
                        <input type="radio" name="exportType" value="download" checked style="margin-right: 5px;">
                        Download to computer
                    </label>
                    <label style="display: block; cursor: pointer;">
                        <input type="radio" name="exportType" value="save" style="margin-right: 5px;">
                        Save to server
                    </label>
                </div>
                <div class="export-dialog-buttons">
                    <button class="file-action-btn" onclick="closeExportDialog()">Cancel</button>
                    <button class="file-action-btn" onclick="handleExport()" style="background: #e8eaf6; font-weight: bold;">Export</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            overlay.onclick = closeExportDialog;
        }

        function closeExportDialog() {
            const overlay = document.getElementById('exportOverlay');
            const dialogs = document.querySelectorAll('.export-dialog');

            if (overlay) overlay.remove();
            dialogs.forEach(d => d.remove());
        }

        async function handleExport() {
            const exportType = document.querySelector('input[name="exportType"]:checked').value;

            closeExportDialog();

            if (exportType === 'download') {
                downloadCSV();
            } else if (exportType === 'save') {
                await saveToServer();
            }
        }

        async function saveToServer() {
            const filename = prompt('Enter a filename for the saved CSV:', `csv_export_${new Date().toISOString().slice(0, 10)}.csv`);

            if (!filename) {
                return; // User cancelled
            }

            const csvContent = generateCSVContent();
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const file = new File([blob], filename, { type: 'text/csv' });

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (!data.success) {
                    alert('Failed to save file: ' + data.error);
                    return;
                }

                alert('File saved successfully!');

                // If user is on saved files tab, reload the list
                if (document.getElementById('savedTab').classList.contains('active')) {
                    loadSavedFiles();
                }
            } catch (error) {
                console.error('Error saving file:', error);
                alert('Failed to save file: ' + error.message);
            }
        }

        // Helper functions
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diff = now - date;
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));

            if (days === 0) {
                const hours = Math.floor(diff / (1000 * 60 * 60));
                if (hours === 0) {
                    const minutes = Math.floor(diff / (1000 * 60));
                    return minutes === 0 ? 'Just now' : `${minutes}m ago`;
                }
                return `${hours}h ago`;
            } else if (days === 1) {
                return 'Yesterday';
            } else if (days < 7) {
                return `${days}d ago`;
            } else {
                return date.toLocaleDateString();
            }
        }

        // Add header functionality
        function showAddHeaderDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'export-dialog-overlay';
            overlay.id = 'headerDialogOverlay';

            const firstRow = rawFileData[0];
            const secondRow = rawFileData.length > 1 ? rawFileData[1] : null;
            const firstRowValues = firstRow.join(', ');
            const secondRowValues = secondRow ? secondRow.join(', ') : '';

            const dialog = document.createElement('div');
            dialog.className = 'export-dialog';
            dialog.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: bold;">Change Headers</div>
                <div style="margin-bottom: 10px; font-size: 11px; color: #666;">
                    Current headers: ${firstRowValues.substring(0, 80)}${firstRowValues.length > 80 ? '...' : ''}
                </div>
                ${secondRow ? `<div style="margin-bottom: 10px; font-size: 11px; color: #666;">
                    First data row: ${secondRowValues.substring(0, 80)}${secondRowValues.length > 80 ? '...' : ''}
                </div>` : ''}
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; cursor: pointer;">
                        <input type="radio" name="headerType" value="second-row" ${secondRow ? 'checked' : ''} ${!secondRow ? 'disabled' : ''} style="margin-right: 5px;">
                        Use next row as headers (shift data up)
                    </label>
                    <label style="display: block; cursor: pointer;">
                        <input type="radio" name="headerType" value="custom" ${!secondRow ? 'checked' : ''} style="margin-right: 5px;">
                        Enter custom headers
                    </label>
                </div>
                <div class="export-dialog-buttons">
                    <button class="file-action-btn" onclick="closeHeaderDialog()">Cancel</button>
                    <button class="file-action-btn" onclick="applyHeaders()" style="background: #e8eaf6; font-weight: bold;">Apply</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            overlay.onclick = closeHeaderDialog;
        }

        function closeHeaderDialog() {
            const overlay = document.getElementById('headerDialogOverlay');
            const dialogs = document.querySelectorAll('.export-dialog');

            if (overlay) overlay.remove();
            dialogs.forEach(d => {
                // Only remove header dialogs, not export dialogs
                if (d.textContent.includes('Change Headers')) {
                    d.remove();
                }
            });
        }

        function applyHeaders() {
            const headerType = document.querySelector('input[name="headerType"]:checked').value;

            closeHeaderDialog();

            if (headerType === 'second-row') {
                // Use second row as headers (shift data up one row)
                currentHeaders = rawFileData[1];
                currentData = rawFileData.slice(2);
            } else if (headerType === 'custom') {
                // Prompt for custom headers - use current headers length (already has Checked/Rank stripped)
                const numberOfColumns = currentHeaders.length;
                const newHeadersPrompt = `Enter ${numberOfColumns} column headers separated by commas:`;
                const newHeadersInput = prompt(newHeadersPrompt);

                if (newHeadersInput) {
                    const newHeaders = newHeadersInput.split(',').map(h => h.trim());
                    if (newHeaders.length === numberOfColumns) {
                        // Convert current data objects back to arrays using old headers order
                        const oldHeaders = [...currentHeaders]; // Save old headers
                        currentHeaders = newHeaders;

                        // Convert data from objects to arrays based on old headers
                        currentData = currentData.map(row => {
                            return oldHeaders.map(header => row[header]);
                        });
                    } else {
                        alert(`Please provide exactly ${numberOfColumns} headers. You provided ${newHeaders.length}.`);
                        return;
                    }
                } else {
                    return; // User cancelled
                }
            }

            // Check if headers include "Checked" or "Rank" columns (from raw data)
            // These should be UI state, not data columns
            const checkedColumnIndex = currentHeaders.indexOf('Checked');
            const rankColumnIndex = currentHeaders.indexOf('Rank');

            // Strip out Checked/Rank columns if present (when using second-row option)
            if (checkedColumnIndex !== -1 || rankColumnIndex !== -1) {
                // Remove from headers
                currentHeaders = currentHeaders.filter(h => h !== 'Checked' && h !== 'Rank');

                // Remove from data
                currentData = currentData.map(row => {
                    if (Array.isArray(row)) {
                        // If row is still array (from rawFileData), filter by index
                        return row.filter((_, i) => i !== checkedColumnIndex && i !== rankColumnIndex);
                    }
                    return row; // Already processed
                });
            }

            // Remap data with new headers
            currentData = currentData.map((row, index) => {
                const mappedRow = { ID: index + 1 };
                currentHeaders.forEach((header, i) => {
                    mappedRow[header] = row[i] !== undefined ? row[i] : '';
                });
                return mappedRow;
            });

            allData = [...currentData];
            hasCustomHeaders = true;

            // Hide the add header button
            document.getElementById('addHeaderBtn').style.display = 'none';

            // Redisplay the data with new headers
            displayData(currentData);
        }
    </script>
</body>
</html>
