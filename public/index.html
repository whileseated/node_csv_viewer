<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="styles.css">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<title>CSV/TSV Viewer</title>
</head>
<body>
    <div class="options-container" id="optionsContainer" style="display: none;">
        <span id="rowCount" class="row-count-badge"></span>
        <span id="autoSaveIndicator" class="auto-save-indicator" style="display: none;"></span>
        <a href="#" id="showAllLink" onclick="showAllRows()" style="display: none;">Show All</a>
        <input type="text" id="filterInput" class="filter-input" placeholder="Filter rows..." oninput="filterRows()" />
        <a href="#" id="toggleRankColumnLink" onclick="toggleRankColumn()">Rank</a>
        <a href="#" id="toggleCheckmarkColumnLink" onclick="toggleCheckmarkColumn()">Checkmark</a>
        <a href="#" id="showCheckedRowsLink" onclick="toggleCheckedRows()" style="display: none;">Show Checks</a>
        <a href="#" id="toggleDragHandleLink" onclick="toggleDragHandle()">Drag Handle</a>
        <a href="#" id="saveLink" onclick="saveCSV()" style="display: none;">Save</a>
        <a href="#" id="exportCSVLink" onclick="exportCSV()" style="display: none;">Export</a>
    </div>

    <div class="bulk-actions-container" id="bulkActionsContainer" style="display: none;">
        <a href="#" id="checkAllLink" onclick="checkAll()">Check All</a>
        <a href="#" id="checkNoneLink" onclick="checkNone()">Check None</a>
        <a href="#" id="deleteCheckedLink" onclick="deleteCheckedRows()">Delete Checked</a>
    </div>

    <div class="container mt-3">
        <!-- Tab Navigation -->
        <div class="tab-container">
            <button class="delete-button" id="deleteBtn" onclick="showDeleteDialog()" style="display: none;" title="Delete rows or columns">−</button>
            <button class="add-header-button" id="addHeaderBtn" onclick="showAddHeaderDialog()" style="display: none;" title="Change headers">+</button>
            <span class="current-filename" id="currentFilename"></span>
            <button class="tab-button active" id="uploadTab" onclick="switchTab('upload')">Upload New</button>
            <button class="tab-button" id="savedTab" onclick="switchTab('saved')">Saved Files</button>
        </div>

        <!-- Upload Section -->
        <div id="uploadSection" class="upload-section">
            <div id="dropZone" class="drop-zone">
                <div class="drop-zone-icon">⇪</div>
                <div class="drop-zone-text">Drop CSV or TSV file here</div>
                <div class="drop-zone-or">or</div>
                <label for="csvFile" class="file-button">Choose File</label>
                <input type="file" id="csvFile" class="file-input" accept=".csv,.tsv,.txt" />
                <div class="drop-zone-hint">Supports .csv, .tsv, and .txt files</div>
            </div>
        </div>

        <!-- Saved Files Section -->
        <div id="savedFilesSection" class="saved-files-section" style="display: none;">
            <div class="saved-files-container">
                <div id="savedFilesContent">
                    <div class="loading-indicator" id="savedFilesLoading" style="display: none;">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Loading saved files...</div>
                    </div>
                    <div id="savedFilesList"></div>
                </div>
            </div>
        </div>

        <div id="loadingIndicator" class="loading-indicator" style="display: none;">
            <div class="loading-spinner"></div>
            <div class="loading-text">Processing file...</div>
            <div class="loading-details" id="loadingDetails">Parsing rows...</div>
        </div>

        <div class="table-container" id="tableContainer" style="display: none;">
            <table class="table table-striped" id="csvTable">
                <thead class="table-header"></thead>
                <tbody class="table-body"></tbody>
            </table>
        </div>
    </div>

    <script>
        let currentData = [];
        let currentHeaders = null;
        let rawFileData = []; // Store raw file data before headers are applied
        let hasCustomHeaders = false; // Track if user has set custom headers
        let showRankColumn = false;
        let showCheckboxColumn = false;
        let showDragHandle = false;
        let checkedRows = new Set();
        let showCheckedRows = false;
        let currentSort = { column: null, ascending: true }; // Define the current sorting state
        let allData = []; // Store the complete dataset for toggling back
        let unfilteredData = []; // Store data before filter is applied
        let hasSignificantAdjustments = false; // Track if export should be available
        let lastCheckedIndex = null; // Track last checked checkbox for shift-click
        let columnWidths = {}; // Store custom column widths
        let isResizing = false;
        let currentResizeColumn = null;
        let startX = 0;
        let startWidth = 0;
        let currentFilter = ''; // Track current filter text
        let currentSavedFilename = null; // Track currently loaded saved file for auto-save
        let autoSaveTimeout = null; // Debounce timer for auto-save
        let currentFilename = null; // Track current filename to detect reloads
        let savedUIState = null; // Store UI state for file reloads
        let editingHeaderIndex = null; // Track which header is being edited
        let pendingHeaderName = ''; // Current input value while editing
        let originalHeaderName = null; // Preserve original header for rename operations

        // Save current UI state
        function saveUIState() {
            return {
                filter: currentFilter,
                sort: { ...currentSort },
                columnWidths: { ...columnWidths },
                checkedRows: new Set(checkedRows),
                showRankColumn: showRankColumn,
                showCheckboxColumn: showCheckboxColumn,
                showDragHandle: showDragHandle,
                showCheckedRows: showCheckedRows,
                hasSignificantAdjustments: hasSignificantAdjustments,
                currentSavedFilename: currentSavedFilename,
                headers: currentHeaders ? [...currentHeaders] : null
            };
        }

        // Restore UI state after file load
        function restoreUIState(state, isReload) {
            if (!state || !isReload) return;

            // Restore simple flags
            showRankColumn = state.showRankColumn;
            showCheckboxColumn = state.showCheckboxColumn;
            showDragHandle = state.showDragHandle;
            showCheckedRows = state.showCheckedRows;
            hasSignificantAdjustments = state.hasSignificantAdjustments;
            currentSavedFilename = state.currentSavedFilename;

            // Restore column widths if headers match
            if (state.headers && currentHeaders &&
                JSON.stringify(state.headers) === JSON.stringify(currentHeaders)) {
                columnWidths = { ...state.columnWidths };

                // Restore checked rows (they use the same ID system)
                checkedRows = new Set(state.checkedRows);

                // Restore sort
                currentSort = { ...state.sort };
                if (currentSort.column) {
                    const sortFunction = (a, b) => {
                        let valA = a[currentSort.column];
                        let valB = b[currentSort.column];

                        // Try to parse as numbers for proper numeric sorting
                        const numA = parseFloat(valA);
                        const numB = parseFloat(valB);

                        // If both values are valid numbers, compare numerically
                        if (!isNaN(numA) && !isNaN(numB)) {
                            if (numA < numB) return currentSort.ascending ? -1 : 1;
                            if (numA > numB) return currentSort.ascending ? 1 : -1;
                            return 0;
                        }

                        // Otherwise, compare as strings (case-insensitive)
                        const strA = String(valA).toLowerCase();
                        const strB = String(valB).toLowerCase();
                        if (strA < strB) return currentSort.ascending ? -1 : 1;
                        if (strA > strB) return currentSort.ascending ? 1 : -1;
                        return 0;
                    };
                    currentData.sort(sortFunction);
                    allData.sort(sortFunction);
                }

                // Restore filter
                if (state.filter) {
                    currentFilter = state.filter;
                    document.getElementById('filterInput').value = state.filter;
                    unfilteredData = [...currentData];
                    const filterText = state.filter.toLowerCase();
                    currentData = currentData.filter(row => {
                        return currentHeaders.some(header => {
                            const value = row[header];
                            if (value === null || value === undefined) return false;
                            return String(value).toLowerCase().includes(filterText);
                        });
                    });
                }

                // Update button states
                document.getElementById('toggleRankColumnLink').classList.toggle('active', showRankColumn);
                document.getElementById('toggleCheckmarkColumnLink').classList.toggle('active', showCheckboxColumn);
                document.getElementById('toggleDragHandleLink').classList.toggle('active', showDragHandle);
                document.getElementById('showCheckedRowsLink').classList.toggle('active', showCheckedRows);

                // Apply checked rows filter if it was active
                if (showCheckedRows) {
                    currentData = allData.filter(row => checkedRows.has(row.ID));
                }
            }
        }

        // File input event listener
        document.getElementById('csvFile').addEventListener('change', uploadFile);

        // Drag and drop event listeners
        const dropZone = document.getElementById('dropZone');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const validExtensions = ['.csv', '.tsv', '.txt'];
                const isValid = validExtensions.some(ext => file.name.toLowerCase().endsWith(ext));

                if (isValid) {
                    processFile(file, file.name);
                } else {
                    alert('Please drop a CSV, TSV, or TXT file');
                }
            }
        });

        async function uploadFile() {
            const csvFile = document.getElementById('csvFile').files[0];
            if (csvFile) {
                // Clear saved filename when uploading new file (not from server)
                // But keep currentFilename for reload detection (handled in processFile)
                if (csvFile.name !== currentSavedFilename) {
                    currentSavedFilename = null;
                }
                processFile(csvFile, csvFile.name);
            }
        }

        // Auto-save functionality
        function triggerAutoSave() {
            if (!currentSavedFilename) {
                return; // Only auto-save if file was loaded from saved files
            }

            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }

            // Debounce: wait 500ms after last change before saving
            autoSaveTimeout = setTimeout(async () => {
                await performAutoSave();
            }, 500);
        }

        async function performAutoSave() {
            if (!currentSavedFilename || !currentData || currentData.length === 0) {
                return;
            }

            const indicator = document.getElementById('autoSaveIndicator');
            indicator.textContent = 'Saving...';
            indicator.style.display = 'inline-block';

            try {
                // Generate CSV content - use allData to save complete dataset, not filtered view
                const csvContent = generateCSVContent(true);

                // Send update to server
                const response = await fetch(`api/update/${encodeURIComponent(currentSavedFilename)}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ content: csvContent })
                });

                const data = await response.json();

                if (data.success) {
                    indicator.textContent = 'Saved';
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 2000);
                } else {
                    indicator.textContent = 'Save failed';
                    console.error('Auto-save failed:', data.error);
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 3000);
                }
            } catch (error) {
                console.error('Auto-save error:', error);
                indicator.textContent = 'Save failed';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 3000);
            }
        }

        function processFile(file, filename) {
            // Check if this is a reload of the same file
            const isReload = (filename === currentFilename);

            // Save current UI state if reloading
            if (isReload && currentData.length > 0) {
                savedUIState = saveUIState();
            } else {
                savedUIState = null;
            }

            editingHeaderIndex = null;
            originalHeaderName = null;
            pendingHeaderName = '';

            // Update current filename
            currentFilename = filename;

            // Update filename display
            const filenameElement = document.getElementById('currentFilename');
            if (filename) {
                filenameElement.textContent = filename;
            }

            // Hide add header and delete buttons while processing
            document.getElementById('addHeaderBtn').style.display = 'none';
            document.getElementById('deleteBtn').style.display = 'none';

            // Show loading indicator
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('loadingIndicator').style.display = 'block';

            const fileSize = (file.size / 1024 / 1024).toFixed(1); // Size in MB
            document.getElementById('loadingDetails').textContent = `Reading ${fileSize}MB file...`;

            let rowCount = 0;
            let lastUpdate = Date.now();
            let allChunks = []; // Accumulate chunks here

            Papa.parse(file, {
                header: false,
                dynamicTyping: false,
                skipEmptyLines: true,
                chunk: function(results, parser) {
                    // Accumulate data from chunks
                    if (results && results.data) {
                        allChunks.push(...results.data);
                        rowCount += results.data.length;
                    }

                    // Update UI every 200ms to avoid too many updates
                    const now = Date.now();
                    if (now - lastUpdate > 200) {
                        const rowsFormatted = rowCount >= 1000
                            ? `${(rowCount / 1000).toFixed(1)}K`
                            : rowCount;
                        document.getElementById('loadingDetails').textContent =
                            `Parsed ${rowsFormatted} rows from ${fileSize}MB file...`;
                        lastUpdate = now;
                    }
                },
                complete: function (results) {
                    // Log results for debugging
                    console.log('Parse complete. Chunks collected:', allChunks.length);

                    // Use accumulated chunks instead of results.data
                    const data = allChunks;

                    // Check if we have any data
                    if (!data || data.length === 0) {
                        console.error('No data was parsed from the file');
                        document.getElementById('loadingIndicator').style.display = 'none';
                        document.getElementById('uploadSection').style.display = 'block';
                        alert("The file appears to be empty or could not be parsed.");
                        return;
                    }

                    // Log any parsing errors but continue
                    if (results && results.errors && results.errors.length > 0) {
                        console.warn(`Parsing completed with ${results.errors.length} errors:`, results.errors);
                    }

                    const totalRows = data.length;
                    const rowsFormatted = totalRows >= 1000
                        ? `${(totalRows / 1000).toFixed(1)}K`
                        : totalRows;

                    document.getElementById('loadingDetails').textContent =
                        `Processing ${rowsFormatted} rows...`;

                    // Ensure there's data in the file
                    if (data.length === 0) {
                        document.getElementById('loadingIndicator').style.display = 'none';
                        document.getElementById('uploadSection').style.display = 'block';
                        alert("The file is empty.");
                        return;
                    }

                    // Store raw data for later header manipulation
                    rawFileData = data;
                    hasCustomHeaders = false;

                    // Always use first row as headers by default
                    const firstRow = data[0];
                    currentHeaders = firstRow;
                    currentData = data.slice(1);

                    const dataRowsFormatted = currentData.length >= 1000
                        ? `${(currentData.length / 1000).toFixed(1)}K`
                        : currentData.length;

                    document.getElementById('loadingDetails').textContent =
                        `Mapping ${dataRowsFormatted} rows to columns...`;

                    // Use setTimeout to allow UI update before heavy processing
                    setTimeout(() => {
                        // Check if there's a "Checked" or "Rank" column in the headers
                        const checkedColumnIndex = currentHeaders.indexOf('Checked');
                        const rankColumnIndex = currentHeaders.indexOf('Rank');
                        const hasCheckedColumn = checkedColumnIndex !== -1;
                        const hasRankColumn = rankColumnIndex !== -1;

                        // Map the remaining rows to the headers, and add a unique ID
                        currentData = currentData.map((row, index) => {
                            const mappedRow = { ID: index + 1 };
                            currentHeaders.forEach((header, i) => {
                                mappedRow[header] = row[i] !== undefined ? row[i] : '';
                            });
                            return mappedRow;
                        });

                        // If there's a "Checked" column, restore checkbox states
                        if (hasCheckedColumn) {
                            checkedRows.clear();
                            currentData.forEach(row => {
                                const checkedValue = String(row['Checked']).toUpperCase();
                                if (checkedValue === 'TRUE' || checkedValue === '1' || checkedValue === 'YES') {
                                    checkedRows.add(row.ID);
                                }
                            });

                            // Remove "Checked" from headers (it's UI state, not data)
                            currentHeaders = currentHeaders.filter(h => h !== 'Checked');

                            // Remove "Checked" column from data
                            currentData = currentData.map(row => {
                                const newRow = { ...row };
                                delete newRow['Checked'];
                                return newRow;
                            });

                            // Enable checkbox column
                            showCheckboxColumn = true;
                        } else if (!isReload) {
                            // No "Checked" column and not a reload - clear checked rows and reset checkbox column
                            checkedRows.clear();
                            showCheckboxColumn = false;
                        }

                        // If there's a "Rank" column, remove it and enable rank column
                        if (hasRankColumn) {
                            // Remove "Rank" from headers (it's UI state, not data)
                            currentHeaders = currentHeaders.filter(h => h !== 'Rank');

                            // Remove "Rank" column from data
                            currentData = currentData.map(row => {
                                const newRow = { ...row };
                                delete newRow['Rank'];
                                return newRow;
                            });

                            // Enable rank column
                            showRankColumn = true;
                        } else if (!isReload) {
                            // No "Rank" column and not a reload - reset rank column
                            showRankColumn = false;
                        }

                        allData = [...currentData];

                        document.getElementById('loadingDetails').textContent =
                            `Rendering ${dataRowsFormatted} rows...`;

                        // Use setTimeout to allow UI to update before rendering
                        setTimeout(() => {
                            // Restore UI state if this is a reload
                            restoreUIState(savedUIState, isReload);

                            // Hide loading and show table
                            document.getElementById('loadingIndicator').style.display = 'none';
                            document.getElementById('tableContainer').style.display = 'block';
                            document.getElementById('optionsContainer').style.display = 'flex';

                            // Show delete button whenever data is loaded
                            document.getElementById('deleteBtn').style.display = 'block';

                            // Show add header button if using default headers
                            if (!hasCustomHeaders) {
                                document.getElementById('addHeaderBtn').style.display = 'block';
                            }

                            // Only clear filter input and state if NOT reloading
                            if (!isReload) {
                                document.getElementById('filterInput').value = '';
                                currentFilter = '';
                                unfilteredData = [];
                            }

                            // Update button states if they were automatically enabled (only on fresh load)
                            if (!isReload) {
                                if (showCheckboxColumn) {
                                    document.getElementById('toggleCheckmarkColumnLink').classList.add('active');
                                }
                                if (showRankColumn) {
                                    document.getElementById('toggleRankColumnLink').classList.add('active');
                                }
                            }

                            displayData(currentData);
                            updateUIVisibility(); // Ensure UI state is correct
                        }, 50);
                    }, 50);
                },
                error: function (error) {
                    console.error('Parsing Error:', error);
                    document.getElementById('loadingIndicator').style.display = 'none';
                    document.getElementById('uploadSection').style.display = 'block';

                    let errorMsg = "An error occurred while parsing the file.";
                    if (error.message) {
                        errorMsg += `\n\nError: ${error.message}`;
                    }
                    if (error.row !== undefined) {
                        errorMsg += `\nRow: ${error.row}`;
                    }
                    errorMsg += "\n\nCheck the browser console for more details.";

                    alert(errorMsg);
                }
            });
        }

        function displayData(data) {
            if (!data || data.length === 0 || !currentHeaders) {
                console.error("No data or headers to display");
                return;
            }

            // Update row count display
            const rowCountElement = document.getElementById('rowCount');
            const formattedCount = data.length >= 1000
                ? `${(data.length / 1000).toFixed(1)}K`
                : data.length;
            rowCountElement.textContent = `${formattedCount} rows`;

            const tableHeader = document.querySelector('.table-header');
            const tableBody = document.querySelector('.table-body');

            // Create the header row with sorting functionality
            let headerRow = '<tr>';
            if (showDragHandle) headerRow += '<th style="width: 40px;">⠿</th>';
            if (showRankColumn) headerRow += '<th>Rank</th>';
            if (showCheckboxColumn) headerRow += '<th>Check</th>';
            currentHeaders.forEach((header, index) => {
                let sortClass = 'sortable';
                if (currentSort.column === header) {
                    sortClass += currentSort.ascending ? ' sorted-asc' : ' sorted-desc';
                }
                const width = columnWidths[header] ? `style="width: ${columnWidths[header]}px;"` : '';
                const isEditing = editingHeaderIndex === index;
                const headerContent = isEditing
                    ? `<input id="headerEditInput"
                              class="header-edit-input"
                              value="${escapeHtml(pendingHeaderName || header)}"
                              oninput="handleHeaderInput(event)"
                              onkeydown="handleHeaderKeyDown(event)"
                              onblur="commitHeaderEdit()"
                              aria-label="Edit column name" />`
                    : `<span class="header-label"
                            onclick="sortDataByHeaderIndex(${index})"
                            ondblclick="startHeaderEdit(${index}); event.stopPropagation();"
                            title="Click to sort • Double-click to rename">${escapeHtml(header)}</span>`;

                headerRow += `<th class="${sortClass} resizable-header" ${width} data-column="${header}">
                    <div class="header-cell">
                        ${headerContent}
                        <div class="resize-handle" data-column="${header}"></div>
                    </div>
                </th>`;
            });
            headerRow += '</tr>';
            tableHeader.innerHTML = headerRow;

            // Attach resize event listeners
            attachResizeListeners();

            // Create the data rows with drag-and-drop functionality
            // Use array join instead of innerHTML concatenation for better performance
            const rows = data.map((row, rowIndex) => {
                let dataRow = `<tr ondragover="handleDragOver(event)" ondrop="handleDrop(event, ${rowIndex})">`;

                if (showDragHandle) {
                    dataRow += `<td class="drag-handle" draggable="true" ondragstart="handleDragStart(event, ${rowIndex})" style="cursor: grab; text-align: center;">⠿</td>`;
                }
                if (showRankColumn) dataRow += `<td>${rowIndex + 1}</td>`;
                if (showCheckboxColumn) {
                    const isChecked = checkedRows.has(row.ID) ? 'checked' : '';
                    dataRow += `<td><input type="checkbox" ${isChecked} data-row-id="${row.ID}" data-row-index="${rowIndex}" onclick="handleCheckboxChange(${row.ID}, ${rowIndex}, this, event)"></td>`;
                }
                currentHeaders.forEach(header => {
                    const cellValue = row[header];
                    const formattedValue = makeLinksClickable(cellValue);
                    dataRow += `<td>${formattedValue}</td>`;
                });
                dataRow += '</tr>';
                return dataRow;
            });

            tableBody.innerHTML = rows.join('');

            // Update the checked rows button text to reflect current count
            if (showCheckboxColumn) {
                updateCheckedRowsButtonText();
            }
        }

        function makeLinksClickable(text) {
            if (text === null || text === undefined || text === '') return '';

            const textStr = String(text);
            // Quick check: if no http in the string, skip regex
            if (!textStr.includes('http://') && !textStr.includes('https://')) {
                return textStr;
            }

            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return textStr.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
        }

        function escapeHtml(str) {
            if (str === null || str === undefined) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function updateUIVisibility() {
            // Show "Show Only Checked Rows" only when checkboxes are enabled
            const showCheckedRowsLink = document.getElementById('showCheckedRowsLink');
            if (showCheckboxColumn) {
                showCheckedRowsLink.style.display = 'inline-block';
            } else {
                showCheckedRowsLink.style.display = 'none';
            }

            // Show bulk actions (Check All, Check None) only when checkboxes are enabled
            const bulkActionsContainer = document.getElementById('bulkActionsContainer');
            if (showCheckboxColumn) {
                bulkActionsContainer.style.display = 'flex';
            } else {
                bulkActionsContainer.style.display = 'none';
            }

            // Show save button only when file is from saved files
            const saveLink = document.getElementById('saveLink');
            if (currentSavedFilename) {
                saveLink.style.display = 'inline-block';
            } else {
                saveLink.style.display = 'none';
            }

            // Show export button only when significant adjustments have been made
            const exportLink = document.getElementById('exportCSVLink');
            if (hasSignificantAdjustments) {
                exportLink.style.display = 'inline-block';
            } else {
                exportLink.style.display = 'none';
            }

            // Show "Show All" button when viewing filtered data
            const showAllLink = document.getElementById('showAllLink');
            if (showCheckedRows || currentFilter !== '') {
                showAllLink.style.display = 'inline-block';
            } else {
                showAllLink.style.display = 'none';
            }

            // Update the checked rows button text with count
            updateCheckedRowsButtonText();
        }

        function updateCheckedRowsButtonText() {
            const showCheckedRowsLink = document.getElementById('showCheckedRowsLink');
            const count = checkedRows.size;

            if (showCheckedRows) {
                showCheckedRowsLink.textContent = `Showing ${count} Check${count === 1 ? '' : 's'}`;
            } else {
                if (count > 0) {
                    showCheckedRowsLink.textContent = `Show ${count} Check${count === 1 ? '' : 's'}`;
                } else {
                    showCheckedRowsLink.textContent = 'Show Checks';
                }
            }
        }

        function updateRowCount() {
            const rowCountElement = document.getElementById('rowCount');
            const formattedCount = currentData.length >= 1000
                ? `${(currentData.length / 1000).toFixed(1)}K`
                : currentData.length;
            rowCountElement.textContent = `${formattedCount} rows`;
        }

        function sortDataByHeaderIndex(index) {
            const header = currentHeaders?.[index];
            if (!header) return;
            sortData(header);
        }

        function startHeaderEdit(index) {
            editingHeaderIndex = index;
            originalHeaderName = currentHeaders[index];
            pendingHeaderName = currentHeaders[index];
            displayData(currentData);
            // Defer focus until after render
            setTimeout(() => {
                const input = document.getElementById('headerEditInput');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 0);
        }

        function handleHeaderInput(event) {
            pendingHeaderName = event.target.value;
        }

        function handleHeaderKeyDown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                commitHeaderEdit();
            } else if (event.key === 'Escape') {
                event.preventDefault();
                cancelHeaderEdit();
            }
        }

        function renameColumns(oldName, newName) {
            const renameRow = (row) => {
                const newRow = { ...row };
                newRow[newName] = newRow[oldName];
                delete newRow[oldName];
                return newRow;
            };

            currentData = currentData.map(renameRow);
            allData = allData.map(renameRow);

            if (unfilteredData.length > 0) {
                unfilteredData = unfilteredData.map(renameRow);
            }

            if (columnWidths[oldName]) {
                columnWidths[newName] = columnWidths[oldName];
                delete columnWidths[oldName];
            }

            if (currentSort.column === oldName) {
                currentSort.column = newName;
            }
        }

        function commitHeaderEdit() {
            if (editingHeaderIndex === null) return;

            const newName = (pendingHeaderName || '').trim();
            const oldName = originalHeaderName;
            const headerIndex = editingHeaderIndex;

            editingHeaderIndex = null;
            originalHeaderName = null;
            pendingHeaderName = '';

            // If unchanged or empty, just re-render
            if (!newName || newName === oldName) {
                displayData(currentData);
                return;
            }

            // Prevent duplicate header names
            const duplicateIndex = currentHeaders.findIndex((h, idx) => idx !== headerIndex && h === newName);
            if (duplicateIndex !== -1) {
                alert('A column with that name already exists. Please choose another.');
                displayData(currentData);
                return;
            }

            currentHeaders[headerIndex] = newName;
            renameColumns(oldName, newName);

            hasCustomHeaders = true;
            markAsAdjusted();
            displayData(currentData);
            triggerAutoSave();
        }

        function cancelHeaderEdit() {
            editingHeaderIndex = null;
            originalHeaderName = null;
            pendingHeaderName = '';
            displayData(currentData);
        }

        function markAsAdjusted() {
            hasSignificantAdjustments = true;
            updateUIVisibility();
        }

        function toggleRankColumn() {
            showRankColumn = !showRankColumn;
            document.getElementById('toggleRankColumnLink').classList.toggle('active', showRankColumn);
            if (showRankColumn) {
                markAsAdjusted();
            } else {
                // Still update visibility when toggling off
                updateUIVisibility();
            }
            displayData(currentData);
        }

        function toggleCheckmarkColumn() {
            showCheckboxColumn = !showCheckboxColumn;
            document.getElementById('toggleCheckmarkColumnLink').classList.toggle('active', showCheckboxColumn);
            if (showCheckboxColumn) {
                markAsAdjusted();
            } else {
                // Still update visibility when toggling off
                updateUIVisibility();
            }
            displayData(currentData);
        }

        function toggleDragHandle() {
            showDragHandle = !showDragHandle;
            document.getElementById('toggleDragHandleLink').classList.toggle('active', showDragHandle);
            displayData(currentData);
        }

        function handleCheckboxChange(rowID, rowIndex, checkboxElem, event) {
            // Ensure rowID is a number to match how IDs are stored in the data
            rowID = Number(rowID);
            // Handle shift-click range selection
            if (event.shiftKey && lastCheckedIndex !== null && lastCheckedIndex !== rowIndex) {
                const start = Math.min(lastCheckedIndex, rowIndex);
                const end = Math.max(lastCheckedIndex, rowIndex);

                // Determine if we're checking or unchecking based on current checkbox state
                const shouldCheck = checkboxElem.checked;

                // Check or uncheck all rows in the range
                for (let i = start; i <= end; i++) {
                    const currentRow = currentData[i];
                    if (currentRow) {
                        if (shouldCheck) {
                            checkedRows.add(currentRow.ID);
                        } else {
                            checkedRows.delete(currentRow.ID);
                        }
                    }
                }

                // Refresh the display to show all checked boxes
                displayData(currentData);
                updateCheckedRowsButtonText();
            } else {
                // Normal single checkbox toggle
                if (checkboxElem.checked) {
                    checkedRows.add(rowID);
                    // Update button text immediately
                    updateCheckedRowsButtonText();
                } else {
                    checkedRows.delete(rowID);

                    // If we're in "Show Checks" mode and unchecking, remove the row visually
                    if (showCheckedRows) {
                        // Find and remove the table row from DOM
                        const tableRow = checkboxElem.closest('tr');
                        if (tableRow) {
                            tableRow.remove();
                            // Update currentData array to match
                            currentData = currentData.filter(row => row.ID !== rowID);
                            // Update counters AFTER removing from checkedRows and currentData
                            updateCheckedRowsButtonText();
                            updateRowCount();
                        }
                    } else {
                        // Not in "Show Checks" mode, just update button text
                        updateCheckedRowsButtonText();
                    }
                }
            }

            lastCheckedIndex = rowIndex;
            triggerAutoSave();
        }

        function checkAll() {
            currentData.forEach(row => {
                checkedRows.add(row.ID);
            });
            displayData(currentData);
            updateCheckedRowsButtonText();
            triggerAutoSave();
        }

        function checkNone() {
            checkedRows.clear();
            displayData(currentData);
            updateCheckedRowsButtonText();
            triggerAutoSave();
        }

        function deleteCheckedRows() {
            if (checkedRows.size === 0) {
                alert('No rows are checked');
                return;
            }

            const count = checkedRows.size;
            if (!confirm(`Are you sure you want to delete ${count} checked row${count === 1 ? '' : 's'}? This cannot be undone.`)) {
                return;
            }

            // Remove checked rows from both currentData and allData
            currentData = currentData.filter(row => !checkedRows.has(row.ID));
            allData = allData.filter(row => !checkedRows.has(row.ID));

            // Reassign IDs to maintain sequential numbering
            currentData = currentData.map((row, index) => ({
                ...row,
                ID: index + 1
            }));
            allData = allData.map((row, index) => ({
                ...row,
                ID: index + 1
            }));

            // Clear checked rows since they've been deleted
            checkedRows.clear();

            // If we were in "Show Checks" mode, exit it since there are no more checked rows
            if (showCheckedRows) {
                showCheckedRows = false;
                document.getElementById('showCheckedRowsLink').classList.remove('active');
            }

            // Mark as adjusted and trigger auto-save
            markAsAdjusted();
            displayData(currentData);
            updateCheckedRowsButtonText();
            updateUIVisibility();
            triggerAutoSave();
        }

        // Column resizing functionality
        function attachResizeListeners() {
            const resizeHandles = document.querySelectorAll('.resize-handle');

            resizeHandles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    isResizing = true;
                    currentResizeColumn = handle.getAttribute('data-column');
                    startX = e.pageX;

                    const th = handle.closest('th');
                    startWidth = th.offsetWidth;

                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                });
            });
        }

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            const diff = e.pageX - startX;
            const newWidth = Math.max(50, startWidth + diff); // Minimum width of 50px

            columnWidths[currentResizeColumn] = newWidth;

            // Update the column width immediately
            const th = document.querySelector(`th[data-column="${currentResizeColumn}"]`);
            if (th) {
                th.style.width = newWidth + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                currentResizeColumn = null;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        function toggleCheckedRows() {
            showCheckedRows = !showCheckedRows;

            if (showCheckedRows) {
                // Only display rows that are checked
                currentData = allData.filter(row => checkedRows.has(row.ID));
                displayData(currentData);
                markAsAdjusted();
            } else {
                // Show all rows again
                currentData = [...allData];
                displayData(currentData);
            }

            document.getElementById('showCheckedRowsLink').classList.toggle('active', showCheckedRows);
            updateCheckedRowsButtonText();
            updateUIVisibility();
        }

        function showAllRows() {
            // Reset checked rows filter
            if (showCheckedRows) {
                showCheckedRows = false;
                document.getElementById('showCheckedRowsLink').classList.remove('active');
                updateCheckedRowsButtonText();
            }

            // Reset search filter
            if (currentFilter !== '') {
                document.getElementById('filterInput').value = '';
                currentFilter = '';
            }

            // Restore all data
            if (unfilteredData.length > 0) {
                currentData = [...unfilteredData];
                unfilteredData = [];
            } else {
                currentData = [...allData];
            }

            displayData(currentData);
            updateUIVisibility();
        }

        // Filter rows based on search term
        function filterRows() {
            const filterInput = document.getElementById('filterInput');
            const filterText = filterInput.value.toLowerCase().trim();

            // If filter is empty, restore unfiltered data
            if (filterText === '') {
                if (currentFilter !== '') {
                    // Was filtering before, now clearing
                    currentData = [...allData];
                    currentFilter = '';
                    unfilteredData = [];
                    displayData(currentData);
                    updateUIVisibility();
                }
                return;
            }

            // Store unfiltered data if this is the first filter
            if (currentFilter === '') {
                unfilteredData = [...allData];
            }

            // Filter data - search across all columns (always filter from allData to ensure we have complete dataset)
            const filtered = allData.filter(row => {
                // Check each column value
                return currentHeaders.some(header => {
                    const value = row[header];
                    if (value === null || value === undefined) return false;
                    return String(value).toLowerCase().includes(filterText);
                });
            });

            currentFilter = filterText;
            currentData = filtered;
            displayData(currentData);

            // DON'T trigger auto-save on filter - filtering is UI state, not data change
            // Remove this to prevent saving filtered data:
            // if (filterText !== '') {
            //     markAsAdjusted();
            // }

            updateUIVisibility();
        }

        function parseCSV(file) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    complete: (result) => {
                        console.log('Parsed Data:', result.data); // Debugging line
                        resolve(result.data);
                    },
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true,
                    error: (error) => {
                        console.error('Parsing Error:', error); // Error handling
                        reject(error);
                    },
                });
            });
        }

        // Drag-and-drop row reordering functionality
        function handleDragStart(event, index) {
            draggedRowIndex = index;
            event.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(event, index) {
            event.preventDefault();
            if (draggedRowIndex !== null && draggedRowIndex !== index) {
                const draggedRow = currentData.splice(draggedRowIndex, 1)[0];
                currentData.splice(index, 0, draggedRow);
                markAsAdjusted();
                displayData(currentData);
                triggerAutoSave();
            }
        }

        // Sorting functionality
        function sortData(column) {
            // Toggle sorting order if the same column is clicked again
            if (currentSort.column === column) {
                currentSort.ascending = !currentSort.ascending;
            } else {
                currentSort.column = column;
                currentSort.ascending = true;
            }

            // Sort function to be used for both arrays
            const sortFunction = (a, b) => {
                let valA = a[column];
                let valB = b[column];

                // Try to parse as numbers for proper numeric sorting
                const numA = parseFloat(valA);
                const numB = parseFloat(valB);

                // If both values are valid numbers, compare numerically
                if (!isNaN(numA) && !isNaN(numB)) {
                    if (numA < numB) return currentSort.ascending ? -1 : 1;
                    if (numA > numB) return currentSort.ascending ? 1 : -1;
                    return 0;
                }

                // Otherwise, compare as strings (case-insensitive)
                const strA = String(valA).toLowerCase();
                const strB = String(valB).toLowerCase();
                if (strA < strB) return currentSort.ascending ? -1 : 1;
                if (strA > strB) return currentSort.ascending ? 1 : -1;
                return 0;
            };

            // Sort both the current data and all data to maintain sort across filters
            currentData.sort(sortFunction);
            allData.sort(sortFunction);

            markAsAdjusted();

            // If showing only checked rows, re-filter after sorting
            if (showCheckedRows) {
                const filteredData = allData.filter(row => checkedRows.has(row.ID));
                displayData(filteredData);
            } else {
                displayData(currentData);
            }

            triggerAutoSave();
        }

        // Export CSV functionality
        function exportCSV() {
            if (!currentData || currentData.length === 0 || !currentHeaders) {
                alert("No data to export");
                return;
            }

            // Show export dialog
            showExportDialog();
        }

        function generateCSVContent(useFullData = false) {
            // Build CSV content
            let csvContent = '';

            // Add headers
            let headers = [];
            if (showRankColumn) {
                headers.push('Rank');
            }
            if (showCheckboxColumn) {
                headers.push('Checked');
            }
            headers = headers.concat(currentHeaders);
            csvContent += headers.map(h => `"${h}"`).join(',') + '\n';

            // Determine which data to export
            // When useFullData is true (auto-save), always use allData to preserve complete dataset
            // When exporting manually, use currentData which may be filtered
            const dataToExport = useFullData ? allData : (showCheckedRows ? currentData : currentData);

            dataToExport.forEach((row, index) => {
                let rowData = [];

                // Add rank if enabled
                if (showRankColumn) {
                    rowData.push(index + 1);
                }

                // Add checked state if checkboxes enabled
                if (showCheckboxColumn) {
                    rowData.push(checkedRows.has(row.ID) ? 'TRUE' : 'FALSE');
                }

                // Add all other columns
                currentHeaders.forEach(header => {
                    const value = row[header];
                    // Escape quotes and wrap in quotes if contains comma, quote, or newline
                    const stringValue = value !== null && value !== undefined ? String(value) : '';
                    const escapedValue = stringValue.replace(/"/g, '""');
                    rowData.push(`"${escapedValue}"`);
                });

                csvContent += rowData.join(',') + '\n';
            });

            return csvContent;
        }

        function downloadCSV() {
            const csvContent = generateCSVContent();

            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `csv_export_${timestamp}.csv`;

            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Tab switching functionality
        function switchTab(tab) {
            if (tab === 'upload') {
                document.getElementById('uploadTab').classList.add('active');
                document.getElementById('savedTab').classList.remove('active');
                document.getElementById('uploadSection').style.display = 'block';
                document.getElementById('savedFilesSection').style.display = 'none';
                // Show delete button if we have data loaded
                if (currentData.length > 0) {
                    document.getElementById('deleteBtn').style.display = 'block';
                }
                // Show add header button if using default headers
                if (!hasCustomHeaders && currentData.length > 0) {
                    document.getElementById('addHeaderBtn').style.display = 'block';
                }
                // Show filename if we have data loaded
                // (filename is already set by processFile, so no need to change it here)
            } else if (tab === 'saved') {
                // Check if saved tab is already active - if so, just collapse the list
                const savedTabActive = document.getElementById('savedTab').classList.contains('active');
                const savedFilesVisible = document.getElementById('savedFilesSection').style.display === 'block';

                if (savedTabActive && savedFilesVisible) {
                    // Just collapse the saved files list, keep button active
                    document.getElementById('savedFilesSection').style.display = 'none';
                } else {
                    // Show saved files
                    document.getElementById('uploadTab').classList.remove('active');
                    document.getElementById('savedTab').classList.add('active');
                    document.getElementById('uploadSection').style.display = 'none';
                    document.getElementById('savedFilesSection').style.display = 'block';
                    // Hide buttons when viewing saved files
                    document.getElementById('deleteBtn').style.display = 'none';
                    document.getElementById('addHeaderBtn').style.display = 'none';
                    // Load saved files when switching to this tab
                    loadSavedFiles();
                }
            }
        }

        // Saved files management
        async function loadSavedFiles() {
            const loadingIndicator = document.getElementById('savedFilesLoading');
            const filesList = document.getElementById('savedFilesList');

            loadingIndicator.style.display = 'block';
            filesList.innerHTML = '';

            try {
                const response = await fetch('api/saved-files');
                const data = await response.json();

                loadingIndicator.style.display = 'none';

                if (!data.success) {
                    filesList.innerHTML = '<div class="empty-state">Error loading files</div>';
                    return;
                }

                if (data.files.length === 0) {
                    filesList.innerHTML = '<div class="empty-state">No saved files yet. Upload and save a CSV to get started.</div>';
                    return;
                }

                // Build table
                let tableHTML = `
                    <table class="saved-files-table">
                        <thead>
                            <tr>
                                <th>Filename</th>
                                <th>Size</th>
                                <th>Last Modified</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                data.files.forEach(file => {
                    const size = formatFileSize(file.size);
                    const date = formatDate(file.lastModified);
                    tableHTML += `
                        <tr>
                            <td class="filename-cell">
                                <span class="filename-display" id="filename-${file.filename}">${file.filename}</span>
                                <input type="text" class="filename-input" id="input-${file.filename}"
                                       value="${file.filename}" style="display: none;">
                            </td>
                            <td>${size}</td>
                            <td>${date}</td>
                            <td>
                                <div class="file-actions">
                                    <button class="file-action-btn" onclick="loadSavedFile('${file.filename}')">Load</button>
                                    <button class="file-action-btn" onclick="startRename('${file.filename}')">Rename</button>
                                    <button class="file-action-btn delete" onclick="deleteSavedFile('${file.filename}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table>';
                filesList.innerHTML = tableHTML;
            } catch (error) {
                console.error('Error loading saved files:', error);
                loadingIndicator.style.display = 'none';
                filesList.innerHTML = '<div class="empty-state">Error loading files</div>';
            }
        }

        async function loadSavedFile(filename) {
            try {
                const response = await fetch(`api/file/${encodeURIComponent(filename)}`);
                if (!response.ok) {
                    throw new Error('Failed to load file');
                }

                const blob = await response.blob();
                const file = new File([blob], filename, { type: 'text/csv' });

                // Reset header state when loading a saved file
                hasCustomHeaders = false;
                rawFileData = [];

                // Track which saved file is loaded for auto-save
                currentSavedFilename = filename;

                // Switch to upload tab and process the file
                switchTab('upload');
                processFile(file, filename);
            } catch (error) {
                console.error('Error loading file:', error);
                alert('Failed to load file: ' + error.message);
            }
        }

        function startRename(filename) {
            const displaySpan = document.getElementById(`filename-${filename}`);
            const inputField = document.getElementById(`input-${filename}`);

            displaySpan.style.display = 'none';
            inputField.style.display = 'inline-block';
            inputField.focus();
            inputField.select();

            // Handle Enter key
            inputField.onkeydown = async (e) => {
                if (e.key === 'Enter') {
                    await finishRename(filename, inputField.value);
                } else if (e.key === 'Escape') {
                    cancelRename(filename);
                }
            };

            // Handle blur (clicking outside)
            inputField.onblur = async () => {
                if (inputField.value !== filename) {
                    await finishRename(filename, inputField.value);
                } else {
                    cancelRename(filename);
                }
            };
        }

        async function finishRename(oldFilename, newFilename) {
            if (newFilename === oldFilename) {
                cancelRename(oldFilename);
                return;
            }

            if (!newFilename || newFilename.trim() === '') {
                alert('Filename cannot be empty');
                cancelRename(oldFilename);
                return;
            }

            try {
                const response = await fetch(`api/rename/${encodeURIComponent(oldFilename)}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ newFilename: newFilename })
                });

                const data = await response.json();

                if (!data.success) {
                    alert('Failed to rename file: ' + data.error);
                    cancelRename(oldFilename);
                    return;
                }

                // Reload the files list
                loadSavedFiles();
            } catch (error) {
                console.error('Error renaming file:', error);
                alert('Failed to rename file: ' + error.message);
                cancelRename(oldFilename);
            }
        }

        function cancelRename(filename) {
            const displaySpan = document.getElementById(`filename-${filename}`);
            const inputField = document.getElementById(`input-${filename}`);

            displaySpan.style.display = 'inline';
            inputField.style.display = 'none';
        }

        async function deleteSavedFile(filename) {
            if (!confirm(`Are you sure you want to delete "${filename}"? This cannot be undone.`)) {
                return;
            }

            try {
                const response = await fetch(`api/delete/${encodeURIComponent(filename)}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (!data.success) {
                    alert('Failed to delete file: ' + data.error);
                    return;
                }

                // Reload the files list
                loadSavedFiles();
            } catch (error) {
                console.error('Error deleting file:', error);
                alert('Failed to delete file: ' + error.message);
            }
        }

        // Export dialog functionality
        function showExportDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'export-dialog-overlay';
            overlay.id = 'exportOverlay';

            const dialog = document.createElement('div');
            dialog.className = 'export-dialog';
            dialog.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: bold;">Export CSV</div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; cursor: pointer;">
                        <input type="radio" name="exportType" value="download" checked style="margin-right: 5px;">
                        Download to computer
                    </label>
                    <label style="display: block; cursor: pointer;">
                        <input type="radio" name="exportType" value="save" style="margin-right: 5px;">
                        Save to server
                    </label>
                </div>
                <div class="export-dialog-buttons">
                    <button class="file-action-btn" onclick="closeExportDialog()">Cancel</button>
                    <button class="file-action-btn" onclick="handleExport()" style="background: #e8eaf6; font-weight: bold;">Export</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            overlay.onclick = closeExportDialog;
        }

        function closeExportDialog() {
            const overlay = document.getElementById('exportOverlay');
            const dialogs = document.querySelectorAll('.export-dialog');

            if (overlay) overlay.remove();
            dialogs.forEach(d => d.remove());
        }

        async function handleExport() {
            const exportType = document.querySelector('input[name="exportType"]:checked').value;

            closeExportDialog();

            if (exportType === 'download') {
                downloadCSV();
            } else if (exportType === 'save') {
                await saveToServer();
            }
        }

        async function saveCSV() {
            if (!currentSavedFilename) {
                alert('No saved file is currently loaded');
                return;
            }

            try {
                // Generate CSV content - use allData to save complete dataset
                const csvContent = generateCSVContent(true);

                // Send update to server
                const response = await fetch(`api/update/${encodeURIComponent(currentSavedFilename)}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ content: csvContent })
                });

                const data = await response.json();

                if (data.success) {
                    // Show brief success message
                    const saveLink = document.getElementById('saveLink');
                    const originalText = saveLink.textContent;
                    saveLink.textContent = 'Saved!';
                    setTimeout(() => {
                        saveLink.textContent = originalText;
                    }, 1500);
                } else {
                    alert('Failed to save file: ' + data.error);
                }
            } catch (error) {
                console.error('Error saving file:', error);
                alert('Failed to save file: ' + error.message);
            }
        }

        async function saveToServer() {
            let filename = prompt('Enter a filename for the saved CSV:', `csv_export_${new Date().toISOString().slice(0, 10)}`);

            if (!filename) {
                return; // User cancelled
            }

            // Automatically add .csv extension if not present
            if (!filename.toLowerCase().endsWith('.csv')) {
                filename = filename + '.csv';
            }

            const csvContent = generateCSVContent();
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const file = new File([blob], filename, { type: 'text/csv' });

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('api/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (!data.success) {
                    alert('Failed to save file: ' + data.error);
                    return;
                }

                alert('File saved successfully!');

                // If user is on saved files tab, reload the list
                if (document.getElementById('savedTab').classList.contains('active')) {
                    loadSavedFiles();
                }
            } catch (error) {
                console.error('Error saving file:', error);
                alert('Failed to save file: ' + error.message);
            }
        }

        // Helper functions
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diff = now - date;
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));

            if (days === 0) {
                const hours = Math.floor(diff / (1000 * 60 * 60));
                if (hours === 0) {
                    const minutes = Math.floor(diff / (1000 * 60));
                    return minutes === 0 ? 'Just now' : `${minutes}m ago`;
                }
                return `${hours}h ago`;
            } else if (days === 1) {
                return 'Yesterday';
            } else if (days < 7) {
                return `${days}d ago`;
            } else {
                return date.toLocaleDateString();
            }
        }

        // Delete functionality
        function showDeleteDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'export-dialog-overlay';
            overlay.id = 'deleteDialogOverlay';

            const dialog = document.createElement('div');
            dialog.className = 'export-dialog';
            dialog.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: bold;">Delete Rows or Columns</div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; cursor: pointer;">
                        <input type="radio" name="deleteType" value="rows" checked style="margin-right: 5px;">
                        Delete checked rows
                    </label>
                    <label style="display: block; cursor: pointer;">
                        <input type="radio" name="deleteType" value="columns" style="margin-right: 5px;">
                        Delete a column
                    </label>
                </div>
                <div class="export-dialog-buttons">
                    <button class="file-action-btn" onclick="closeDeleteDialog()">Cancel</button>
                    <button class="file-action-btn" onclick="handleDelete()" style="background: #ffebee; font-weight: bold;">Delete</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            overlay.onclick = closeDeleteDialog;
        }

        function closeDeleteDialog() {
            const overlay = document.getElementById('deleteDialogOverlay');
            const dialogs = document.querySelectorAll('.export-dialog');

            if (overlay) overlay.remove();
            dialogs.forEach(d => {
                if (d.textContent.includes('Delete Rows or Columns') || d.textContent.includes('Select Column to Delete')) {
                    d.remove();
                }
            });
        }

        function handleDelete() {
            const deleteType = document.querySelector('input[name="deleteType"]:checked').value;

            closeDeleteDialog();

            if (deleteType === 'rows') {
                deleteCheckedRows();
            } else if (deleteType === 'columns') {
                showColumnSelectionDialog();
            }
        }

        function showColumnSelectionDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'export-dialog-overlay';
            overlay.id = 'deleteDialogOverlay';

            const dialog = document.createElement('div');
            dialog.className = 'export-dialog';

            let columnsHTML = '';
            currentHeaders.forEach((header, index) => {
                columnsHTML += `
                    <label style="display: block; margin-bottom: 5px; cursor: pointer;">
                        <input type="radio" name="columnToDelete" value="${index}" ${index === 0 ? 'checked' : ''} style="margin-right: 5px;">
                        ${header}
                    </label>
                `;
            });

            dialog.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: bold;">Select Column to Delete</div>
                <div style="margin-bottom: 10px; max-height: 300px; overflow-y: auto;">
                    ${columnsHTML}
                </div>
                <div class="export-dialog-buttons">
                    <button class="file-action-btn" onclick="closeDeleteDialog()">Cancel</button>
                    <button class="file-action-btn" onclick="deleteSelectedColumn()" style="background: #ffebee; font-weight: bold;">Delete Column</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            overlay.onclick = closeDeleteDialog;
        }

        function deleteSelectedColumn() {
            const selectedIndex = document.querySelector('input[name="columnToDelete"]:checked').value;
            const columnIndex = parseInt(selectedIndex);
            const columnName = currentHeaders[columnIndex];

            if (!confirm(`Are you sure you want to delete the column "${columnName}"? This cannot be undone.`)) {
                closeDeleteDialog();
                return;
            }

            closeDeleteDialog();

            // Remove the column from headers
            currentHeaders.splice(columnIndex, 1);

            // Remove the column from all data
            currentData = currentData.map(row => {
                const newRow = { ...row };
                delete newRow[columnName];
                return newRow;
            });

            allData = allData.map(row => {
                const newRow = { ...row };
                delete newRow[columnName];
                return newRow;
            });

            // Remove from unfiltered data if it exists
            if (unfilteredData.length > 0) {
                unfilteredData = unfilteredData.map(row => {
                    const newRow = { ...row };
                    delete newRow[columnName];
                    return newRow;
                });
            }

            // Remove from column widths
            if (columnWidths[columnName]) {
                delete columnWidths[columnName];
            }

            // Mark as adjusted and trigger auto-save
            markAsAdjusted();
            displayData(currentData);
            triggerAutoSave();
        }

        // Add header functionality
        function showAddHeaderDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'export-dialog-overlay';
            overlay.id = 'headerDialogOverlay';

            const firstRow = rawFileData[0];
            const secondRow = rawFileData.length > 1 ? rawFileData[1] : null;
            const firstRowValues = firstRow.join(', ');
            const secondRowValues = secondRow ? secondRow.join(', ') : '';

            const dialog = document.createElement('div');
            dialog.className = 'export-dialog';
            dialog.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: bold;">Change Headers</div>
                <div style="margin-bottom: 10px; font-size: 11px; color: #666;">
                    Current headers: ${firstRowValues.substring(0, 80)}${firstRowValues.length > 80 ? '...' : ''}
                </div>
                ${secondRow ? `<div style="margin-bottom: 10px; font-size: 11px; color: #666;">
                    First data row: ${secondRowValues.substring(0, 80)}${secondRowValues.length > 80 ? '...' : ''}
                </div>` : ''}
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; cursor: pointer;">
                        <input type="radio" name="headerType" value="second-row" ${secondRow ? 'checked' : ''} ${!secondRow ? 'disabled' : ''} style="margin-right: 5px;">
                        Use next row as headers (shift data up)
                    </label>
                    <label style="display: block; cursor: pointer;">
                        <input type="radio" name="headerType" value="custom" ${!secondRow ? 'checked' : ''} style="margin-right: 5px;">
                        Enter custom headers
                    </label>
                </div>
                <div class="export-dialog-buttons">
                    <button class="file-action-btn" onclick="closeHeaderDialog()">Cancel</button>
                    <button class="file-action-btn" onclick="applyHeaders()" style="background: #e8eaf6; font-weight: bold;">Apply</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            overlay.onclick = closeHeaderDialog;
        }

        function closeHeaderDialog() {
            const overlay = document.getElementById('headerDialogOverlay');
            const dialogs = document.querySelectorAll('.export-dialog');

            if (overlay) overlay.remove();
            dialogs.forEach(d => {
                // Only remove header dialogs, not export dialogs
                if (d.textContent.includes('Change Headers')) {
                    d.remove();
                }
            });
        }

        function applyHeaders() {
            const headerType = document.querySelector('input[name="headerType"]:checked').value;

            closeHeaderDialog();

            if (headerType === 'second-row') {
                // Use second row as headers (shift data up one row)
                currentHeaders = rawFileData[1];
                currentData = rawFileData.slice(2);
            } else if (headerType === 'custom') {
                // Prompt for custom headers - use current headers length (already has Checked/Rank stripped)
                const numberOfColumns = currentHeaders.length;
                const newHeadersPrompt = `Enter ${numberOfColumns} column headers separated by commas:`;
                const newHeadersInput = prompt(newHeadersPrompt);

                if (newHeadersInput) {
                    const newHeaders = newHeadersInput.split(',').map(h => h.trim());
                    if (newHeaders.length === numberOfColumns) {
                        // Convert current data objects back to arrays using old headers order
                        const oldHeaders = [...currentHeaders]; // Save old headers
                        currentHeaders = newHeaders;

                        // Convert data from objects to arrays based on old headers
                        currentData = currentData.map(row => {
                            return oldHeaders.map(header => row[header]);
                        });
                    } else {
                        alert(`Please provide exactly ${numberOfColumns} headers. You provided ${newHeaders.length}.`);
                        return;
                    }
                } else {
                    return; // User cancelled
                }
            }

            // Check if headers include "Checked" or "Rank" columns (from raw data)
            // These should be UI state, not data columns
            const checkedColumnIndex = currentHeaders.indexOf('Checked');
            const rankColumnIndex = currentHeaders.indexOf('Rank');

            // Strip out Checked/Rank columns if present (when using second-row option)
            if (checkedColumnIndex !== -1 || rankColumnIndex !== -1) {
                // Remove from headers
                currentHeaders = currentHeaders.filter(h => h !== 'Checked' && h !== 'Rank');

                // Remove from data
                currentData = currentData.map(row => {
                    if (Array.isArray(row)) {
                        // If row is still array (from rawFileData), filter by index
                        return row.filter((_, i) => i !== checkedColumnIndex && i !== rankColumnIndex);
                    }
                    return row; // Already processed
                });
            }

            // Remap data with new headers
            currentData = currentData.map((row, index) => {
                const mappedRow = { ID: index + 1 };
                currentHeaders.forEach((header, i) => {
                    mappedRow[header] = row[i] !== undefined ? row[i] : '';
                });
                return mappedRow;
            });

            allData = [...currentData];
            hasCustomHeaders = true;

            // Hide the add header button
            document.getElementById('addHeaderBtn').style.display = 'none';

            // Redisplay the data with new headers
            displayData(currentData);
        }
    </script>
</body>
</html>
